<!DOCTYPE html>
<html lang="uk">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IBONARIUM — Жива Павутина v3.0</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&family=Outfit:wght@300;400;600&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-color: #010105;
            --accent-a: #9d8aff;
            /* ORDER */
            --accent-b: #ff5ab5;
            /* FLUX */
            --accent-c: #00f2ff;
            /* ETHER / NEBULA */
            --text-color: #d0c8ff;
            --glass: rgba(5, 2, 12, 0.85);
            --border: rgba(157, 138, 255, 0.2);
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Outfit', sans-serif;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
            color: var(--text-color);
            width: 200px;
            /* Narrower UI */
            text-shadow: 0 0 15px rgba(0, 0, 0, 0.9);
        }

        h1 {
            margin: 0 0 12px 0;
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            background: linear-gradient(90deg, #a78dff, #ff78d2);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr;
            /* Vertical for narrowness */
            gap: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .metric {
            padding: 4px 0;
            border-bottom: 1px solid rgba(157, 138, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: baseline;
        }

        .label {
            color: rgba(208, 200, 255, 0.5);
            font-size: 0.6rem;
            text-transform: uppercase;
        }

        .value {
            font-weight: 500;
            color: #fff;
            font-size: 0.85rem;
        }

        .influence-panel {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(157, 138, 255, 0.2);
        }

        .civ-bar-container {
            height: 2px;
            /* Thinner */
            background: rgba(255, 255, 255, 0.05);
            margin: 8px 0;
            display: flex;
        }

        .civ-bar {
            height: 100%;
            transition: width 2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .bar-a {
            background: var(--accent-a);
            box-shadow: 0 0 10px var(--accent-a);
        }

        .bar-b {
            background: var(--accent-b);
            box-shadow: 0 0 10px var(--accent-b);
        }

        .bar-c {
            background: var(--accent-c);
            box-shadow: 0 0 10px var(--accent-c);
        }

        .civ-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            font-family: 'JetBrains Mono', monospace;
            opacity: 0.8;
        }

        .status-footer {
            margin-top: 15px;
            font-size: 0.6rem;
            color: rgba(208, 200, 255, 0.4);
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .sync-active {
            color: #22c55e;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .sync-dot {
            width: 4px;
            height: 4px;
            background: currentColor;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.3;
                transform: scale(1.5);
            }
        }

        /* Mobile Adaptation */
        @media (max-width: 600px) {
            #ui {
                top: 15px;
                left: 15px;
                width: calc(100% - 30px);
                max-width: 160px;
                /* Even narrower on mobile */
            }

            h1 {
                font-size: 0.9rem;
            }

            .metric .value {
                font-size: 0.75rem;
            }

            .status-footer {
                font-size: 0.55rem;
            }
        }

        #proxy-warning {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 100, 100, 0.1);
            color: rgba(255, 128, 128, 0.8);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.65rem;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 100, 100, 0.2);
            display: none;
            z-index: 100;
        }

        .uptime-container {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.65rem;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.8;
            pointer-events: none;
        }

        .uptime-label {
            color: var(--accent);
            display: block;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .uptime-value {
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            color: #fff;
            display: block;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <div id="ui">
        <h1>
            <span>IBONARIUM</span>
            <span id="system-status" style="font-size: 0.5em; letter-spacing: 1px;">SYNCING</span>
        </h1>

        <div class="metrics-grid">
            <div class="metric">
                <span class="label">Kp Index</span>
                <span class="value" id="kp-val">--</span>
            </div>
            <div class="metric">
                <span class="label">Wind Speed</span>
                <span class="value" id="wind-val">--</span>
            </div>
            <div class="metric">
                <span class="label">Bz Field</span>
                <span class="value" id="bz-val">--</span>
            </div>
            <div class="metric">
                <span class="label">Density</span>
                <span class="value" id="dens-val">--</span>
            </div>
        </div>

        <div class="uptime-container">
            <span class="uptime-label">Система активована 31.01.2026</span>
            <span class="uptime-value" id="uptime-clock">0d 0h 0m 0s</span>
        </div>

        <div class="influence-panel">
            <div class="civ-info">
                <span style="color: var(--accent-a)">ORDER</span>
                <span style="color: var(--accent-b)">FLUX</span>
                <span style="color: var(--accent-c)">ETHER</span>
            </div>
            <div class="civ-bar-container">
                <div id="bar-a" class="civ-bar bar-a" style="width: 33%"></div>
                <div id="bar-b" class="civ-bar bar-b" style="width: 33%"></div>
                <div id="bar-c" class="civ-bar bar-c" style="width: 34%"></div>
            </div>
            <div class="civ-info" style="font-size: 0.65rem; opacity: 0.6;">
                <span id="stat-a">0.0%</span>
                <span id="stat-b">0.0%</span>
                <span id="stat-c">0.0%</span>
            </div>
        </div>

        <div class="status-footer">
            <div class="sync-active">
                <div class="sync-dot"></div>
                Real-time NOAA Stream Active
            </div>
            <div id="update-timer">Next update in: 60s</div>
            <div id="nodes-count">Nodes: 0 | Edges: 0</div>
        </div>
    </div>

    <div id="proxy-warning">
        ⚠️ CORS Blocked. Using simulated live stream. Run via server for real NOAA data.
    </div>

    <script>
        /**
         * IBONARIUM v3.0 - THE LIVING CONSTELLATION
         * Architecture: Space-Logic Driven Procedural Animation
         */

        const CONFIG = {
            nodeCount: 450,
            connectionDist: 160,
            baseSpeed: 0.08,
            friction: 0.99,
            updateInterval: 60000,
            proxy: 'https://api.allorigins.win/raw?url=',
            cameraZoom: 1.0,
            starScale: 1.2
        };

        class WeatherSystem {
            constructor() {
                this.data = {
                    kp: 2.0,       // Global magnetic activity (0-9). High Kp = More Chaos.
                    wind: 400.0,   // Solar wind speed (300-900). High Wind = Faster movement.
                    bz: 0.0,       // Interplanetary Magnetic Field. Negative Bz = Instability.
                    density: 5.0,  // Proton density. High Density = Brighter connections.
                    storm: 0,      // Calculated storm intensity.
                    nebula: 0      // Third force: Ether intensity (based on density waves)
                };
                this.isSimulated = false;
            }

            async sync() {
                try {
                    // We try to fetch real data from NOAA.
                    // Note: If running locally via file://, CORS will block this.
                    const sources = [
                        'https://services.swpc.noaa.gov/products/noaa-planetary-k-index.json',
                        'https://services.swpc.noaa.gov/products/solar-wind/plasma-5-minute.json'
                    ];

                    const [kpRes, windRes] = await Promise.all([
                        fetch(CONFIG.proxy + encodeURIComponent(sources[0])).then(r => r.json()),
                        fetch(CONFIG.proxy + encodeURIComponent(sources[1])).then(r => r.json())
                    ]);

                    // Parse Kp (Last value in array)
                    const latestKp = parseFloat(kpRes[kpRes.length - 1][1]);
                    this.data.kp = isNaN(latestKp) ? this.data.kp : latestKp;

                    // Parse Plasma (Wind and Density)
                    const latestPlasma = windRes[windRes.length - 1];
                    this.data.density = parseFloat(latestPlasma[1]) || this.data.density;
                    this.data.wind = parseFloat(latestPlasma[2]) || this.data.wind;

                    // Bz isn't in plasma but we simulate its effect based on Kp
                    this.data.bz = (4 - this.data.kp) * 1.5;

                    this.isSimulated = false;
                    document.getElementById('proxy-warning').style.display = 'none';
                } catch (e) {
                    console.warn("Real-time sync failed, falling back to simulation.", e);
                    this.isSimulated = true;
                    this.simulateWeather();
                    document.getElementById('proxy-warning').style.display = 'block';
                }

                this.calculateStorm();
                this.updateUI();
            }

            simulateWeather() {
                // Smoothly drift simulated values if API fails
                this.data.kp += (Math.random() - 0.5) * 0.5;
                this.data.kp = Math.max(0, Math.min(9, this.data.kp));

                this.data.wind += (Math.random() - 0.5) * 20;
                this.data.wind = Math.max(300, Math.min(800, this.data.wind));

                this.data.bz += (Math.random() - 0.5) * 1.0;
                this.data.density += (Math.random() - 0.5) * 2;
            }

            calculateStorm() {
                // Storm probability increases with Kp and Wind
                this.data.storm = Math.max(0, (this.data.kp - 4) / 5);
                // Nebula/Ether intensity peaks when density is high and pulses with time
                const densityFactor = Math.min(1, this.data.density / 15);
                const pulse = (Math.sin(Date.now() * 0.0001) + 1) / 2;
                this.data.nebula = densityFactor * pulse;
            }

            updateUI() {
                document.getElementById('kp-val').textContent = this.data.kp.toFixed(1);
                document.getElementById('wind-val').textContent = Math.round(this.data.wind) + ' km/s';
                document.getElementById('bz-val').textContent = this.data.bz.toFixed(1) + ' nT';
                document.getElementById('dens-val').textContent = this.data.density.toFixed(1) + ' p/cm³';

                const status = document.getElementById('system-status');
                if (this.data.kp > 5) {
                    status.textContent = 'STORM ALERT';
                    status.style.color = '#ff4e4e';
                } else if (this.data.nebula > 0.7) {
                    status.textContent = 'NEBULA RISE';
                    status.style.color = 'var(--accent-c)';
                } else {
                    status.textContent = 'OPTIMAL';
                    status.style.color = '#a78dff';
                }
            }
        }

        class Node {
            constructor(w, h) {
                this.x = Math.random() * w;
                this.y = Math.random() * h;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                // Bigger stars as requested
                this.radius = (Math.random() * 2.5 + 1.0) * CONFIG.starScale;
                this.type = Math.random() > 0.6 ? (Math.random() > 0.8 ? 'C' : 'B') : 'A'; // A=Order, B=Flux, C=Constellation Hub
                this.phase = Math.random() * Math.PI * 2;
                this.pulse = 0;
            }

            update(weather, w, h) {
                // MOTION LOGIC
                // Slow down the movement as requested
                const speedMult = CONFIG.baseSpeed * (weather.wind / 350) * (1 + weather.storm);

                // Kp index adds "jitter" (chaos)
                const jitter = weather.kp * 0.02;

                this.vx += (Math.random() - 0.5) * jitter;
                this.vy += (Math.random() - 0.5) * jitter;

                // Solar Wind Pushes slightly to the right
                this.vx += (weather.wind - 300) * 0.00001;

                this.x += this.vx * speedMult;
                this.y += this.vy * speedMult;

                // Screen Wrap
                if (this.x < 0) this.x = w;
                if (this.x > w) this.x = 0;
                if (this.y < 0) this.y = h;
                if (this.y > h) this.y = 0;

                this.vx *= CONFIG.friction;
                this.vy *= CONFIG.friction;

                // Animation phase
                this.pulse = Math.sin(Date.now() * 0.001 + this.phase);
            }
        }

        class IbonariumEngine {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.weather = new WeatherSystem();
                this.nodes = [];
                this.w = 0;
                this.h = 0;
                this.lastUpdate = Date.now();

                this.init();
                this.handleResize();
                window.addEventListener('resize', () => this.handleResize());

                // Start Cycle
                this.weather.sync();
                setInterval(() => {
                    this.weather.sync();
                    this.lastUpdate = Date.now();
                }, CONFIG.updateInterval);

                this.loop();
            }

            init() {
                this.w = window.innerWidth;
                this.h = window.innerHeight;
                this.canvas.width = this.w;
                this.canvas.height = this.h;

                for (let i = 0; i < CONFIG.nodeCount; i++) {
                    this.nodes.push(new Node(this.w, this.h));
                }
            }

            handleResize() {
                this.w = window.innerWidth;
                this.h = window.innerHeight;
                this.canvas.width = this.w;
                this.canvas.height = this.h;
            }

            update() {
                this.nodes.forEach(n => n.update(this.weather.data, this.w, this.h));

                // Update Timer UI
                const timeLeft = Math.max(0, 60 - Math.floor((Date.now() - this.lastUpdate) / 1000));
                document.getElementById('update-timer').textContent = `Next update in: ${timeLeft}s`;
            }

            draw() {
                const ws = this.weather.data;
                const time = Date.now() * 0.001;

                // Trail effect (Opacity affected by Kp)
                const trailAlpha = Math.max(0.1, 0.4 - (ws.kp * 0.03));

                // Background shifting based on Nebula force
                const hue = 240 + (ws.nebula * 60); // Shifts from blue to purple/cyan
                const sat = 20 + (ws.nebula * 30);
                const lum = 2 + (ws.nebula * 5);

                this.ctx.fillStyle = `hsla(${hue}, ${sat}%, ${lum}%, ${trailAlpha})`;
                this.ctx.fillRect(0, 0, this.w, this.h);

                // CAMERA ZOOM LOGIC
                this.ctx.save();
                this.ctx.translate(this.w / 2, this.h / 2);
                this.ctx.scale(CONFIG.cameraZoom, CONFIG.cameraZoom);
                this.ctx.translate(-this.w / 2, -this.h / 2);

                // DRAW NEBULA GLOW
                this.drawGlow(time, ws);

                let edges = 0;
                this.ctx.lineWidth = 0.5 + (ws.density * 0.05);

                for (let i = 0; i < this.nodes.length; i++) {
                    const n1 = this.nodes[i];

                    for (let j = i + 1; j < this.nodes.length; j++) {
                        const n2 = this.nodes[j];
                        const dx = n1.x - n2.x;
                        const dy = n1.y - n2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        // Connection distance influenced by Bz (negative Bz expands network)
                        const activeDist = CONFIG.connectionDist + (ws.bz < 0 ? Math.abs(ws.bz) * 10 : 0);

                        if (dist < activeDist) {
                            edges++;
                            const opacity = (1 - dist / activeDist) * 0.5;

                            // Constellation logic: if both nodes are "Hubs" or connecting Hub to others
                            let isConstellation = n1.type === 'C' || n2.type === 'C';

                            if (isConstellation && dist < activeDist * 1.5) {
                                this.ctx.lineWidth = (2 + ws.density * 0.1) * (1 - dist / (activeDist * 1.5));
                                this.ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.4})`;
                            } else {
                                this.ctx.lineWidth = 0.5 + (ws.density * 0.05);
                                if (n1.type === 'A' && n2.type === 'A') {
                                    this.ctx.strokeStyle = `rgba(157, 138, 255, ${opacity})`;
                                } else if (n1.type === 'B' && n2.type === 'B') {
                                    this.ctx.strokeStyle = `rgba(255, 90, 181, ${opacity})`;
                                } else {
                                    if (ws.storm > 0.2) {
                                        this.ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                                    } else {
                                        this.ctx.strokeStyle = `rgba(180, 150, 255, ${opacity * 0.3})`;
                                    }
                                }
                            }

                            this.ctx.beginPath();
                            this.ctx.moveTo(n1.x, n1.y);

                            // Storm adds "noise" to lines
                            if (ws.storm > 0.3) {
                                const mx = (n1.x + n2.x) / 2 + (Math.random() - 0.5) * 10 * ws.storm;
                                const my = (n1.y + n2.y) / 2 + (Math.random() - 0.5) * 10 * ws.storm;
                                this.ctx.quadraticCurveTo(mx, my, n2.x, n2.y);
                            } else {
                                this.ctx.lineTo(n2.x, n2.y);
                            }
                            this.ctx.stroke();
                        }
                    }

                    // Draw node with glow
                    const nodeOpacity = 0.5 + n1.pulse * 0.5;
                    const rSize = n1.radius * (1 + n1.pulse * 0.2);

                    if (n1.type === 'C') {
                        // Constellation Hub Glow
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = 'white';
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${nodeOpacity})`;
                    } else {
                        this.ctx.shadowBlur = 5;
                        this.ctx.shadowColor = n1.type === 'A' ? 'var(--accent-a)' : 'var(--accent-b)';
                        this.ctx.fillStyle = n1.type === 'A' ? `rgba(180, 160, 255, ${nodeOpacity})` : `rgba(255, 140, 200, ${nodeOpacity})`;
                    }

                    this.ctx.beginPath();
                    this.ctx.arc(n1.x, n1.y, rSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0; // Reset for next elements
                }

                this.ctx.restore(); // Restore from camera zoom

                document.getElementById('nodes-count').textContent = `Nodes: ${CONFIG.nodeCount} | Edges: ${edges}`;

                // Update Stability Ratio (Three-way balance)
                const total = 100;
                const etherPct = ws.nebula * 40; // Max 40% influence
                const remaining = total - etherPct;

                const orderRatio = (50 + (ws.bz * 5) - (ws.kp * 2)) / 100;
                const orderPct = Math.max(0, Math.min(remaining, remaining * orderRatio));
                const fluxPct = remaining - orderPct;

                document.getElementById('bar-a').style.width = orderPct + '%';
                document.getElementById('bar-b').style.width = fluxPct + '%';
                document.getElementById('bar-c').style.width = etherPct + '%';

                document.getElementById('stat-a').textContent = orderPct.toFixed(1) + '%';
                document.getElementById('stat-b').textContent = fluxPct.toFixed(1) + '%';
                document.getElementById('stat-c').textContent = etherPct.toFixed(1) + '%';
            }

            drawGlow(time, ws) {
                this.ctx.save();
                this.ctx.globalCompositeOperation = 'screen';

                // Density and Nebula force effect ambient brightness
                const ambient = 0.05 + (ws.density * 0.005) + (ws.nebula * 0.1);

                const g1 = this.ctx.createRadialGradient(this.w * 0.3, this.h * 0.3, 0, this.w * 0.3, this.h * 0.3, this.w * 0.6);
                g1.addColorStop(0, `hsla(250, 60%, 15%, ${ambient})`);
                g1.addColorStop(1, 'transparent');

                const g2 = this.ctx.createRadialGradient(this.w * 0.7, this.h * 0.7, 0, this.w * 0.7, this.h * 0.7, this.w * 0.6);
                g2.addColorStop(0, `hsla(320, 60%, 15%, ${ambient})`);
                g2.addColorStop(1, 'transparent');

                // Third Nebula Glow (ETHER)
                if (ws.nebula > 0.2) {
                    const g3 = this.ctx.createRadialGradient(
                        this.w * (0.5 + Math.sin(time * 0.2) * 0.2),
                        this.h * (0.5 + Math.cos(time * 0.2) * 0.2),
                        0,
                        this.w * 0.5, this.h * 0.5, this.w * 0.8
                    );
                    g3.addColorStop(0, `hsla(180, 70%, 20%, ${ws.nebula * 0.2})`);
                    g3.addColorStop(1, 'transparent');
                    this.ctx.fillStyle = g3;
                    this.ctx.fillRect(0, 0, this.w, this.h);
                }

                this.ctx.fillStyle = g1;
                this.ctx.fillRect(0, 0, this.w, this.h);
                this.ctx.fillStyle = g2;
                this.ctx.fillRect(0, 0, this.w, this.h);
                this.ctx.restore();
            }

            loop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.loop());
            }
        }

        // Uptime Clock Logic
        const startDate = new Date('2026-01-31T00:00:00');
        function updateUptime() {
            const now = new Date();
            const diff = now - startDate;

            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);

            const display = document.getElementById('uptime-clock');
            if (display) {
                display.textContent = `${days}d ${hours}h ${minutes}m ${seconds}s`;
            }
        }

        // Start Ibonarium
        window.onload = () => {
            new IbonariumEngine();
            setInterval(updateUptime, 1000);
            updateUptime();
        };
    </script>
</body>

</html>
